<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>M√™ cung: Ng∆∞·ªùi ch∆°i vs AI (RL ‚Äì ƒëa d·∫°ng)</title>
<style>
  :root { --tile: 48px; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    overflow: hidden;
    background: #f7f7fb;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: #222;
    display: grid;
    place-items: center;
    min-height: 100dvh;
  }
  .wrap {
    display: grid;
    gap: 12px;
    padding: 16px;
    background: #fff;
    border: 1px solid #ececf1;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.06);
    width: calc(100dvw - 24px);
    max-width: 880px;
  }
  .row {
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: space-between;
    flex-wrap: wrap;
  }
  .hint { font-size: 13px; color: #666; }
  canvas {
    border-radius: 12px;
    border: 2px solid #1daf28;
    background: #fff;
    width: 100%;
    height: auto;
    display: block;
  }
  button, select, label {
    font-family: inherit;
    font-size: 14px;
  }
  button {
    border: 0;
    background: #111;
    color: #fff;
    padding: 10px 14px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
  }
  button.secondary { background: #e9e9ef; color: #111; }
  select {
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid #e0e0e6;
    background: #fff;
  }
  .stats { display: flex; gap: 14px; font-size: 14px; flex-wrap: wrap; }
  .dot { display:inline-block; width:12px; height:12px; border-radius:50%; margin-right:6px; vertical-align:-2px; }
  .blue { background:#1976d2; }
  .red { background:#e53935; }
  .gold { background:gold; border:1px solid #aa9300; }
  .warn { font-size:12px; color:#d32f2f; opacity:.9; }

  .overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,.6);
    display: none; align-items: center; justify-content: center;
    z-index: 999;
  }
  .overlay.show { display: flex; }
  .countdown {
    color: #fff; text-align: center;
    user-select: none; -webkit-user-select: none;
    padding: 24px 28px; border-radius: 16px; backdrop-filter: blur(4px);
  }
  .countdown .title { font-size: 22px; letter-spacing: 1px; opacity: .9; margin-bottom: 10px; }
  .countdown .number { font-size: 84px; font-weight: 800; line-height: 1; text-shadow: 0 8px 30px rgba(0,0,0,.35); animation: pop .4s ease; }
  @keyframes pop { from { transform: scale(.8); opacity:.2; } to { transform: scale(1); opacity:1; } }

  .result-card {
    background: #fff; color: #111; width: min(90dvw, 420px);
    border-radius: 16px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.2); text-align: center;
  }
  .result-card h3 { margin: 0 0 12px; font-size: 22px; }
  .result-times { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 12px 0 16px; font-size: 14px; }
  .chip { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 999px; background: #f3f4f7; }
  .chip .dot { margin: 0; }
  .btns { display: flex; gap: 10px; justify-content: center; }
  .btns .primary { background: #111; color:#fff; }
  .btns .secondary { background: #e9e9ef; color:#111; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <div class="stats">
        <div><span class="dot blue"></span>Ng∆∞·ªùi ch∆°i</div>
        <div><span class="dot red"></span>"AI"</div>
        <div><span class="dot gold"></span>ƒê√≠ch</div>
      </div>
      <div class="hint">M·∫πo: b·∫•m <b>R</b> ƒë·ªÉ reset nhanh ‚Ä¢ (AI) ch·ªâ b·∫Øt ƒë·∫ßu khi b·∫°n di chuy·ªÉn</div>
    </div>

    <canvas id="maze"></canvas>

    <div class="row">
      <div class="stats" id="status">S·∫µn s√†ng!</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <label for="difficulty">ƒê·ªô kh√≥:</label>
        <select id="difficulty">
          <option value="easy">D·ªÖ</option>
          <option value="normal" selected>B√¨nh th∆∞·ªùng</option>
          <option value="hard">Kh√≥</option>
        </select>
        <button id="btnStart">B·∫Øt ƒë·∫ßu ƒëua</button>
        <button id="btnShow" class="secondary">Hi·ªán/·∫®n b∆∞·ªõc k·∫ø ti·∫øp c·ªßa AI</button>
      </div>
    </div>

    <div id="assetWarning" class="warn" style="display:none;">
      Kh√¥ng t·∫£i ƒë∆∞·ª£c ·∫£nh (s·∫Ω d√πng ch·∫•m m√†u thay th·∫ø). Ki·ªÉm tra ƒë∆∞·ªùng d·∫´n ·∫£nh.
    </div>
  </div>

  <div id="overlay" class="overlay"></div>

<script>
/* ========= M√ä CUNG ========= */
const START_PLAYER = {x:1, y:1};
const START_AI     = {x:1, y:9};
const MAZE = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,1,0,0,0,0,0,0,1],
  [1,0,1,0,1,0,1,0,1,1,0,1],
  [1,0,1,0,0,0,1,0,0,1,0,1],
  [1,0,1,1,1,0,1,1,0,1,0,2],
  [1,0,0,0,0,0,0,0,0,1,0,1],
  [1,0,1,1,0,1,1,1,0,1,0,1],
  [1,0,0,1,0,0,0,1,0,0,0,1],
  [1,0,1,1,0,1,0,1,1,1,0,1],
  [1,0,0,0,0,1,0,0,0,1,0,1],
  [1,1,1,1,0,1,0,1,0,1,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1]
];
const COLS = MAZE[0].length;
const ROWS = MAZE.length;
const GOAL = findGoal(MAZE) || {x: COLS-2, y: 1};

/* ========= PRESETS ƒê·ªò KH√ì ========= */
const DIFFICULTY_PRESETS = {
  easy:   { speedAiMs: 170, aiStepsPerTick: 1, showPathAlpha: 0.35 },
  normal: { speedAiMs: 150, aiStepsPerTick: 2, showPathAlpha: 0.25 },
  hard:   { speedAiMs: 110, aiStepsPerTick: 3, showPathAlpha: 0.12 },
};
let settings = { ...DIFFICULTY_PRESETS.normal };

/* ========= PH·∫¶N T·ª¨ ========= */
const canvas   = document.getElementById("maze");
const statusEl = document.getElementById("status");
const btnStart = document.getElementById("btnStart");
const btnShow  = document.getElementById("btnShow");
const warnEl   = document.getElementById("assetWarning");
const wrapEl   = document.querySelector(".wrap");
const overlay  = document.getElementById("overlay");
const diffSel  = document.getElementById("difficulty");

// Ghi nh·ªõ ƒë·ªô kh√≥ l·∫ßn tr∆∞·ªõc
const savedDiff = localStorage.getItem('maze:difficulty');
if (savedDiff && DIFFICULTY_PRESETS[savedDiff]) {
  settings = { ...DIFFICULTY_PRESETS[savedDiff] };
  diffSel.value = savedDiff;
}

let ctx = canvas.getContext("2d");
let DPR = 1;
let TILE = 48;
const TILE_MIN = 24;
const TILE_MAX = 160;

let player = {...START_PLAYER};
let ai = {...START_AI};
let running = false;
let aiTimer = null;
let showPath = false;
let finished = false;
let t0Player = 0, t0AI = 0;
let countdownLock = false;
let humanStarted = false;

/* üëâ Bi·∫øn k·∫ø ho·∫°ch ƒë·ªÉ v·∫Ω √¥ k·∫ø ti·∫øp m√† AI S·∫ÆP ƒëi */
let aiPlannedAction = null;  // 0..3 ho·∫∑c null
let aiNextCell = null;       // {x,y} ho·∫∑c null

/* ========= ·∫¢NH ========= */
const playerImg = new Image(); playerImg.src = "image/student.png";
const aiImg = new Image();     aiImg.src     = "image/angry.png";
let playerImgOk = false, aiImgOk = false;
playerImg.onload  = () => { playerImgOk = true; draw(); };
aiImg.onload      = () => { aiImgOk = true; draw(); };
playerImg.onerror = () => { warnEl.style.display = "block"; };
aiImg.onerror     = () => { warnEl.style.display = "block"; };

/* ========= TI·ªÜN √çCH ========= */
function findGoal(grid){
  for (let y=0; y<grid.length; y++)
    for (let x=0; x<grid[y].length; x++)
      if (grid[y][x] === 2) return {x,y};
  return null;
}
function canMove(x,y){
  return !(y<0 || y>=ROWS || x<0 || x>=COLS) && MAZE[y][x] !== 1;
}

/* ========= V·∫º ========= */
function draw(){
  ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);

  for (let y=0; y<ROWS; y++){
    for (let x=0; x<COLS; x++){
      if (MAZE[y][x] === 1) ctx.fillStyle = "#1daf28";
      else if (MAZE[y][x] === 2) ctx.fillStyle = "#ffec8a";
      else ctx.fillStyle = "#ffffff";
      ctx.fillRect(x*TILE + 1, y*TILE + 1, TILE - 2, TILE - 2);
    }
  }

  // ‚úÖ Ch·ªâ v·∫Ω √î K·∫æ TI·∫æP m√† AI s·∫Øp ƒëi (kh√¥ng c√≤n ƒë∆∞·ªùng d√†i)
  if (showPath && aiNextCell){
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#e53935";
    ctx.strokeRect(aiNextCell.x * TILE + 5, aiNextCell.y * TILE + 5, TILE - 10, TILE - 10);
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "#e53953";
    ctx.fillRect(aiNextCell.x * TILE + 6, aiNextCell.y * TILE + 6, TILE - 12, TILE - 12);
    ctx.restore();
  }

  drawSprite(player.x, player.y, playerImgOk ? playerImg : null, "#1976d2", { scale: 0.95, mode: "contain" });
  drawSprite(ai.x, ai.y, aiImgOk ? aiImg : null, "#e53935", { scale: 1.15, mode: "contain" });
}

function drawSprite(x, y, img, fallbackColor, { scale = 1.0, mode = "contain", offsetFix = 0 } = {}) {
  const box = TILE * scale;
  if (img && img.complete && (img.naturalWidth || img.width)) {
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    const ar = iw / ih;
    let w, h;
    if (mode === "cover") { if (ar >= 1) { h = box; w = box * ar; } else { w = box; h = box / ar; } }
    else { if (ar >= 1) { w = box; h = box / ar; } else { h = box; w = box * ar; } }
    const dx = x*TILE + (TILE - w)/2 - offsetFix;
    const dy = y*TILE + (TILE - h)/2 - offsetFix;
    const prev = ctx.imageSmoothingEnabled;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, dx, dy, w, h);
    ctx.imageSmoothingEnabled = prev;
  } else {
    ctx.fillStyle = fallbackColor;
    ctx.beginPath();
    const r = Math.min(box, TILE) * 0.33;
    ctx.arc(x*TILE + TILE/2 - offsetFix, y*TILE + TILE/2 - offsetFix, r, 0, Math.PI*2);
    ctx.fill();
  }
}

/* ========= Q-LEARNING (ƒëa d·∫°ng) ========= */
const ACTIONS = [
  {dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}
];
const Q = new Map();
const sk = p => `${p.x},${p.y}`;
function getQArr(s){ if (!Q.has(s)) Q.set(s, [0,0,0,0]); return Q.get(s); }

// Hyper-params
const ALPHA  = 0.5;
const GAMMA  = 0.97;
let   EPSILON= 0.15;
const EPS_MIN= 0.05;
const EPS_DECAY = 0.998;

// Softmax temperature
let   TAU = 1.10;
const TAU_MIN = 0.30;
const TAU_DECAY = 0.997;

// Shaping theo BFS
const BASE_STEP_REWARD = -0.02;
const SHAPE_SCALE = 0.45;

// BFS distance map t·ªõi ƒë√≠ch
function bfsDistanceToGoal(){
  const dist = Array.from({length: ROWS}, _ => Array(COLS).fill(Infinity));
  const q = [GOAL];
  dist[GOAL.y][GOAL.x] = 0;
  while (q.length){
    const {x,y} = q.shift();
    for (const {dx,dy} of ACTIONS){
      const nx = x+dx, ny = y+dy;
      if (canMove(nx,ny) && dist[ny][nx] === Infinity){
        dist[ny][nx] = dist[y][x] + 1;
        q.push({x:nx,y:ny});
      }
    }
  }
  return dist;
}
const DIST = bfsDistanceToGoal();
const phi = p => {
  const d = DIST[p.y]?.[p.x];
  return (d!==undefined && isFinite(d)) ? -d : 0;
};

// Warm start nh·∫π
(function warmStart(){
  const BOOST = 0.15, PENALTY = -0.03;
  for (let y=0; y<ROWS; y++){
    for (let x=0; x<COLS; x++){
      if (!canMove(x,y)) continue;
      const s = sk({x,y});
      const q = getQArr(s);
      const dHere = DIST[y][x];
      for (let a=0; a<4; a++){
        const nx = x + ACTIONS[a].dx, ny = y + ACTIONS[a].dy;
        if (!canMove(nx,ny)) { q[a] += PENALTY; continue; }
        const dNext = DIST[ny][nx];
        if (isFinite(dHere) && isFinite(dNext)){
          if (dNext < dHere) q[a] += BOOST;
          else if (dNext > dHere) q[a] += PENALTY;
        }
      }
    }
  }
})();

function validActions(pos){
  const acts = [];
  for (let a=0; a<4; a++){
    const nx = pos.x + ACTIONS[a].dx, ny = pos.y + ACTIONS[a].dy;
    if (canMove(nx,ny)) acts.push(a);
  }
  return acts.length ? acts : [0,1,2,3];
}

function softmaxSample(q, acts, tau){
  let maxv = -Infinity;
  acts.forEach(a => { if (q[a] > maxv) maxv = q[a]; });
  const exps = acts.map(a => Math.exp((q[a]-maxv) / Math.max(1e-6, tau)));
  const sum = exps.reduce((s,v)=>s+v,0);
  let r = Math.random() * sum;
  for (let i=0; i<acts.length; i++){
    r -= exps[i];
    if (r <= 0) return acts[i];
  }
  return acts[acts.length-1];
}

function chooseAction(pos){
  const acts = validActions(pos);
  if (Math.random() < EPSILON){
    return acts[Math.floor(Math.random()*acts.length)];
  }
  const q = getQArr(sk(pos));
  return softmaxSample(q, acts, TAU);
}

function stepEnv(pos, action, visitCounts){
  const nx = pos.x + ACTIONS[action].dx;
  const ny = pos.y + ACTIONS[action].dy;
  const next = {x:nx, y:ny};
  const done = (nx===GOAL.x && ny===GOAL.y);

  let r = BASE_STEP_REWARD + SHAPE_SCALE * (GAMMA * phi(next) - phi(pos));
  if (done) r += 1.0;

  const key = sk(next);
  const visits = (visitCounts.get(key) || 0) + 1;
  r -= Math.min(0.03 * (visits-1), 0.20);
  visitCounts.set(key, visits);

  return {next, reward: r, done};
}
function updateQ(s, a, r, s2){
  const q = getQArr(s);
  const maxQ2 = Math.max(...getQArr(s2));
  q[a] = q[a] + ALPHA * (r + GAMMA * maxQ2 - q[a]);
}

/* üëâ L·∫≠p k·∫ø ho·∫°ch b∆∞·ªõc t·ªõi ƒë·ªÉ v·∫Ω √î K·∫æ TI·∫æP */
function planNextStep(){
  const a = chooseAction(ai);
  const nx = ai.x + ACTIONS[a].dx;
  const ny = ai.y + ACTIONS[a].dy;
  return { a, next: { x: nx, y: ny } };
}

/* ========= GAME FLOW ========= */
function resetGame(){
  player = {...START_PLAYER};
  ai = {...START_AI};
  running = false;
  finished = false;
  if (aiTimer) { clearInterval(aiTimer); aiTimer = null; }
  humanStarted = false;
  t0Player = 0; t0AI = 0;
  EPSILON = 0.15; TAU = 1.10;
  aiPlannedAction = null;
  aiNextCell = null;
  statusEl.textContent = "S·∫µn s√†ng!";
  draw();
}

function startRace(){
  running = true;
  statusEl.textContent = "GO! B·∫°n di chuy·ªÉn tr∆∞·ªõc ‚Ä¢ AI RL s·∫Ω ch·∫°y ngay khi b·∫°n b∆∞·ªõc";
  draw();
}

function startAiLoop() {
  if (aiTimer) { clearInterval(aiTimer); aiTimer = null; }
  t0AI = performance.now();

  const visitCounts = new Map();
  visitCounts.set(sk(ai), 1);

  aiPlannedAction = null;
  if (showPath && running && !finished) {
  const plan = planNextStep();
  aiPlannedAction = plan.a;
  aiNextCell = plan.next;
} else {
  aiPlannedAction = null;
  aiNextCell = null;
}

  aiTimer = setInterval(()=>{
    if (finished || !running){ clearInterval(aiTimer); aiTimer=null; return; }

    // N·∫øu ƒëang b·∫≠t hi·ªÉn th·ªã v√† ch∆∞a c√≥ k·∫ø ho·∫°ch: l·∫≠p k·∫ø ho·∫°ch & v·∫Ω ngay
    if (showPath && !aiNextCell) {
      const plan = planNextStep();
      aiPlannedAction = plan.a;
      aiNextCell = plan.next;
      draw(); // cho ng∆∞·ªùi ch∆°i th·∫•y √¥ k·∫ø ti·∫øp tr∆∞·ªõc khi AI b∆∞·ªõc
    }

    for (let k=0; k<settings.aiStepsPerTick; k++){
      if (finished || !running) break;

      // B∆∞·ªõc ƒë·∫ßu d√πng ƒë√∫ng h√†nh ƒë·ªông ƒë√£ v·∫Ω (n·∫øu c√≥)
      let a;
      if (aiPlannedAction !== null) {
        a = aiPlannedAction;
        aiPlannedAction = null;
      } else {
        a = chooseAction(ai);
      }

      const s = sk(ai);
      const {next, reward, done} = stepEnv(ai, a, visitCounts);
      const s2 = sk(next);
      updateQ(s, a, reward, s2);

      ai = next;

      EPSILON = Math.max(EPS_MIN, EPSILON * EPS_DECAY);
      TAU     = Math.max(TAU_MIN, TAU * TAU_DECAY);

      if (done){
        finished = true;
        running = false;
        clearInterval(aiTimer); aiTimer=null;
        const tPlayer = t0Player ? ((performance.now() - t0Player)/1000).toFixed(2) : "‚Äî";
        const tAI     = t0AI ? ((performance.now() - t0AI)/1000).toFixed(2) : "‚Äî";
        showResultPopup(false, true, tPlayer, tAI);
        break;
      }
    }

    // Sau khi ƒë√£ b∆∞·ªõc xong trong tick n√†y, hu·ª∑ k·∫ø ho·∫°ch c≈©
    aiNextCell = null;

    draw();
  }, settings.speedAiMs);
}

/* Ng∆∞·ªùi th·∫Øng tr∆∞·ªõc */
function checkFinishByPlayer(){
  if (player.x===GOAL.x && player.y===GOAL.y){
    finished = true; running = false;
    if (aiTimer) { clearInterval(aiTimer); aiTimer=null; }
    const tPlayer = t0Player ? ((performance.now() - t0Player)/1000).toFixed(2) : "‚Äî";
    const tAI     = t0AI ? ((performance.now() - t0AI)/1000).toFixed(2) : "‚Äî";
    showResultPopup(true, false, tPlayer, tAI);
    return true;
  }
  return false;
}

/* ========= OVERLAY ========= */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
async function showCountdownThenStart(){
  countdownLock = true;
  resetGame();

  overlay.className = "overlay show";
  overlay.innerHTML = `
    <div class="countdown">
      <div class="title">B·∫ÆT ƒê·∫¶U ƒêUA</div>
      <div class="number">3</div>
    </div>
  `;
  const numberEl = overlay.querySelector('.number');
  const titleEl  = overlay.querySelector('.title');

  numberEl.textContent = "3"; await sleep(800);
  numberEl.textContent = "2"; numberEl.style.animation = "none"; numberEl.offsetHeight; numberEl.style.animation = "pop .4s ease"; await sleep(800);
  numberEl.textContent = "1"; numberEl.style.animation = "none"; numberEl.offsetHeight; numberEl.style.animation = "pop .4s ease"; await sleep(800);
  titleEl.textContent = "";
  numberEl.textContent = "GO!";
  numberEl.style.animation = "none"; numberEl.offsetHeight; numberEl.style.animation = "pop .4s ease";

  await sleep(450);
  overlay.className = "overlay";
  countdownLock = false;
  startRace();
}

function showResultPopup(playerWin, aiWin, tPlayer, tAI){
  let title = playerWin ? (aiWin ? "Ho√† üéâ" : "B·∫°n th·∫Øng üéâ") : "AI th·∫Øng ü§ñ";
  overlay.className = "overlay show";
  overlay.innerHTML = `
    <div class="result-card">
      <h3>${title}</h3>
      <div class="result-times">
        <div class="chip"><span class="dot blue"></span><b>Ng∆∞·ªùi:</b>&nbsp;${tPlayer}s</div>
        <div class="chip"><span class="dot red"></span><b>AI</b>&nbsp;${tAI}s</div>
      </div>
      <div class="btns">
        <button class="secondary" id="btnClose">ƒê√≥ng</button>
        <button class="primary"   id="btnReplay">Ch∆°i l·∫°i</button>
      </div>
    </div>
  `;
  document.getElementById('btnClose').onclick = ()=>{ overlay.className = "overlay"; };
  document.getElementById('btnReplay').onclick = ()=>{ overlay.className = "overlay"; showCountdownThenStart(); };
}

/* ========= AUTO-FIT TILE & DPI ========= */
function resize() {
  const rows = wrapEl.querySelectorAll('.row');
  let rowsH = 0;
  rows.forEach(r => rowsH += r.getBoundingClientRect().height);

  const cs = getComputedStyle(wrapEl);
  const pTop = parseFloat(cs.paddingTop);
  const pBot = parseFloat(cs.paddingBottom);
  const bTop = parseFloat(cs.borderTopWidth);
  const bBot = parseFloat(cs.borderBottomWidth);
  const wrapInnerW = wrapEl.clientWidth - parseFloat(cs.paddingLeft) - parseFloat(cs.paddingRight);

  const availW = wrapInnerW;
  const availH = window.innerHeight - (rowsH + pTop + pBot + bTop + bBot) - 8;

  const tileCandidate = Math.floor(Math.min(availW / COLS, availH / ROWS));
  TILE = Math.max(TILE_MIN, Math.min(TILE_MAX, tileCandidate));

  const cssW = COLS * TILE;
  const cssH = ROWS * TILE;

  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.style.width  = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width  = Math.floor(cssW * DPR);
  canvas.height = Math.floor(cssH * DPR);
  ctx = canvas.getContext("2d");
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  draw();
}

/* ========= INPUT ========= */
btnStart.addEventListener("click", ()=>{ if (!countdownLock) showCountdownThenStart(); });
btnShow.addEventListener("click", ()=>{ 
  showPath = !showPath; 
  // n·∫øu ƒëang ch·∫°y v√† b·∫≠t l√™n th√¨ l·∫≠p k·∫ø ho·∫°ch & v·∫Ω ngay √¥ k·∫ø ti·∫øp
  if (showPath && running && !finished) {
    const plan = planNextStep();
    aiPlannedAction = plan.a;
    aiNextCell = plan.next;
  } else if (!showPath) {
    aiNextCell = null;
    aiPlannedAction = null;
  }
  draw(); 
});

diffSel.addEventListener('change', (e) => {
  const mode = e.target.value;
  const preset = DIFFICULTY_PRESETS[mode];
  if (!preset) return;
  settings = { ...preset };
  localStorage.setItem('maze:difficulty', mode);

  // ƒê·ªïi t·ªëc ƒë·ªô: kh·ªüi ƒë·ªông l·∫°i v√≤ng l·∫∑p n·∫øu ƒëang ch·∫°y
  if (aiTimer) {
    startAiLoop();
  }
  draw();
});

/* ========= INPUT: B√ÄN PH√çM ========= */
document.addEventListener("keydown", (e) => {
  if (e.key === "r" || e.key === "R") {
    if (!countdownLock) { resetGame(); overlay.className = "overlay"; }
    return;
  }
  if (!running || finished || countdownLock) return;

  if (e.key === "ArrowUp")    { e.preventDefault?.(); movePlayer(0, -1); }
  if (e.key === "ArrowDown")  { e.preventDefault?.(); movePlayer(0,  1); }
  if (e.key === "ArrowLeft")  { e.preventDefault?.(); movePlayer(-1, 0); }
  if (e.key === "ArrowRight") { e.preventDefault?.(); movePlayer(1,  0); }
});

window.addEventListener("resize", resize);

/* ========= INPUT: C·∫¢M ·ª®NG (VU·ªêT) ========= */
let touchStartX = 0, touchStartY = 0;
const SWIPE_THRESHOLD = 20;

canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length !== 1) return;
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}, { passive: false });

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchend", (e) => {
  if (!running || finished || countdownLock) return;
  if (e.changedTouches.length === 0) return;

  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;

  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx >  SWIPE_THRESHOLD)      movePlayer(1, 0);
    else if (dx < -SWIPE_THRESHOLD) movePlayer(-1, 0);
  } else {
    if (dy >  SWIPE_THRESHOLD)      movePlayer(0, 1);
    else if (dy < -SWIPE_THRESHOLD) movePlayer(0, -1);
  }
}, { passive: false });

/* ========= H√ÄM DI CHUY·ªÇN D√ôNG CHUNG ========= */
function movePlayer(dx, dy) {
  const before = { x: player.x, y: player.y };
  tryMove(player, dx, dy);

  if (before.x !== player.x || before.y !== player.y) {
    if (!t0Player) t0Player = performance.now();
    if (!humanStarted) { humanStarted = true; startAiLoop(); }
    if (checkFinishByPlayer()) { draw(); return; }
    draw();
  }
}

/* ========= TH·ª¨ DI CHUY·ªÇN 1 √î ========= */
function tryMove(p, dx, dy) {
  const nx = p.x + dx, ny = p.y + dy;
  if (canMove(nx, ny)) { p.x = nx; p.y = ny; }
}

/* ========= INIT ========= */
resize();
resetGame();
</script>
</body>
</html>
